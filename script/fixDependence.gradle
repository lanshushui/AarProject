import java.util.regex.Matcher
import java.util.regex.Pattern

//修复剔除aar后导致的依赖中断问题
//////////////////获得所有源码依赖的模块 的 间接依赖

def aarConfigManager = gradle.ext.aarConfigManager
def allAArConfigsSize = aarConfigManager.getAllAArConfigs().size()
if (aarConfigManager.getSourceTypeProjectConfig().size() == allAArConfigsSize
        || aarConfigManager.getSourceTypeProjectConfig().size() == allAArConfigsSize) {
    println("全源码模式或者全aar模式，不用分析是否存在依赖中止")
    return
}

HashSet<String> compileProject = new HashSet<>()
aarConfigManager.getSourceTypeProjectConfig().forEach {
    compileProject.add(it.projectPath)
}
//加入特殊的 app模块
compileProject.add("/app")

//step1
//收集所需module的直接依赖
LinkedHashMap<String, HashSet<String>> allDirectDepends = new LinkedHashMap<>()
def collectDepends
collectDepends = { String projectPath ->
    if (allDirectDepends.containsKey(projectPath)) return

    File buildFile = new File("${rootDir}/${projectPath}/build.gradle")
    if (!buildFile.exists()) throw Exception("无法找到 ${projectPath}项目的 build.gradle文件")
    BufferedReader br = new BufferedReader(new FileReader(buildFile))
    HashSet<String> directDepend = new HashSet()
    while (true) {
        String line = br.readLine()
        if (line == null) {
            break
        } else {
            String regex = "projectOrAAr\\(['\"](.*?)['\"]\\)"
            Pattern pattern = Pattern.compile(regex)
            Matcher matcher = pattern.matcher(line)
            if (matcher.find()) {
                String extractedString = matcher.group(1).replaceAll(":", "/")
                // 提取匹配到的第一个括号内的内容
                directDepend.add(extractedString)
            }
        }
    }
    allDirectDepends.put(projectPath, directDepend)
    directDepend.forEach {
        collectDepends(it)
    }
}
compileProject.forEach {
    collectDepends(it)
}
//step2
//根据直接依赖 整理出 module的所有依赖
LinkedHashMap<String, HashSet<String>> allCompleteDepends = new LinkedHashMap<>()
def collectDependsV2
collectDependsV2 = { String str ->
    if (allCompleteDepends.containsKey(str)) return
    HashSet<String> directDepend = allDirectDepends.get(str)
    if (directDepend != null) {
        HashSet<String> completeDepend = new HashSet()
        completeDepend.addAll(directDepend)
        directDepend.forEach {
            collectDependsV2(it)
            def nextDepends = allCompleteDepends.get(it)
            if (nextDepends != null) {
                completeDepend.addAll(nextDepends)
            }
        }
        allCompleteDepends.put(str, completeDepend)
    }
}
allDirectDepends.keySet().forEach {
    collectDependsV2(it)
}

//step3
//剔除1--只需要关注 源码依赖module的所有依赖
Iterator iterator = allCompleteDepends.iterator()
while (iterator.hasNext()) {
    if (!compileProject.contains(iterator.next().key)) {
        iterator.remove()
    }
}

//剔除2--只需要关注 源码依赖module与源码module的依赖关系，且关系是间接依赖
allCompleteDepends.entrySet().forEach {
    String mProject = it.key
    Iterator stringIterator = it.value.iterator()
    while (stringIterator.hasNext()) {
        String oneDepend = stringIterator.next()
        if (!compileProject.contains(oneDepend) || allDirectDepends.get(mProject).contains(oneDepend)) {
            stringIterator.remove()
        }
    }
}
println("源码module之间可能丢失的依赖关系  ${allCompleteDepends}")

//使用 compileOnly 保证编译通过
allCompleteDepends.entrySet().forEach { entry ->
    String mProject = entry.key.replaceAll("/", ":")
    gradle.rootProject.project(mProject).afterEvaluate {
        Project p = it
        p.dependencies {
            entry.value.forEach { d ->
                String dep = d.replaceAll("/", ":")
                compileOnly gradle.rootProject.project(dep)
            }
        }
    }
}



