//针对rootProject 的aar任务
def publishAllAAr = {

    HashSet<String> needPublishProjects = new HashSet<>()

    //保存每个项目发布新版本的信息
    HashMap<String, String> publishVersions = new HashMap<>()
    String tempProjectPath = null
    execCmd("git blame config/aarPomConfig.yml", gradle.rootProject).eachLine { String line ->
        if (line.contains("projectPath:")) {
            tempProjectPath = line.split("projectPath:")[1].trim()
        } else {
            if (line.contains("version:")) {
                publishVersions.put(tempProjectPath, line)
            }
        }
    }
    def aarConfigManager = gradle.ext.aarConfigManager
    aarConfigManager.getAllAArConfigs().forEach {
        //从未发布过，要发布
        if (it.version == "0") {
            needPublishProjects.add(it.projectPath)
        }
        //module最后一次提交和 配置文件内 对应version字段的commit信息是否相符
        //不符合也要发布
        String lastCommitId = getProjectLastCommitId(it.projectPath, gradle)
        if (!publishVersions.get(it.projectPath).contains(lastCommitId)) {
            needPublishProjects.add(it.projectPath)
        }
    }
    if (needPublishProjects.isEmpty()) {
        println("没有需要发布AAR的模块")
        System.exit(0)
    }
    println("所有需要发布AAR的模块 $needPublishProjects")
    StringBuilder sb = new StringBuilder()
    needPublishProjects.forEach {
        sb.append(it)
        sb.append("#")
    }
    String needPublishProjectsStr = sb.toString()
    needPublishProjectsStr = needPublishProjectsStr.substring(0, needPublishProjectsStr.length() - 1)
    //不能把needPublishProjects.toString直接当参数，因为字符串有【,】,会导致命令混乱
    String result = execCmd("gradlew :publishAllAArInner -PneedPublishProjects=${needPublishProjectsStr}", rootProject)
    println(result)
}
gradle.rootProject.task("publishAAr").enabled = false
gradle.rootProject.task("publishAllAAr", group: "publishing") {
    doLast {
        publishAllAAr()
    }
}

class DependStruct {
    HashSet<String> dependDetail = new HashSet<>()
}

gradle.rootProject.task("publishAllAArInner", group: "publishing") {
    doLast {
        //找到所有需要发布的module
        ArrayList<String> needPublishProjectsList = new ArrayList<>()
        String needPublishProjects = gradle.startParameter.projectProperties.get("needPublishProjects")
        if (needPublishProjects == null || needPublishProjects.isEmpty()) {
            println("没有needPublishProjects参数 是不行的")
            return
        }
        needPublishProjects.split("#").each {
            needPublishProjectsList.add(it.trim().replaceAll("/", ":"))
        }
        println("再次确认 所有需要发布AAR的模块 $needPublishProjectsList")

        //进行源码module之间的依赖分析
        HashMap<String, DependStruct> dependMap = new HashMap<>()
        def dfsDependence
        dfsDependence = { String path ->
            if (dependMap.containsKey(path)) {
                return dependMap.get(path)
            }
            def defaultRet = new DependStruct()
            if (!dependMap.containsKey(path)) {
                Project p = gradle.rootProject.project(path)
                p.configurations.each {
                    it.allDependencies.forEach {
                        //只需要找源码module之间的依赖关系
                        if (it instanceof ProjectDependency && it.dependencyProject != p) {
                            DependStruct subDepend = dfsDependence(it.dependencyProject.path)
                            subDepend.dependDetail.forEach {
                                defaultRet.dependDetail.add(it)
                            }
                            defaultRet.dependDetail.add(it.getDependencyProject().path)
                        }
                    }
                }
            }
            dependMap.put(path, defaultRet)
            return defaultRet
        }
        needPublishProjectsList.forEach {
            dfsDependence(it)
        }
        println("已分析完依赖，开始排序")

        //deque保存无依赖的数据
        ArrayDeque<String> deque = new ArrayDeque()
        dependMap.entrySet().forEach {
            if (it.value.dependDetail.isEmpty()) {
                deque.offer(it.key)
            }
        }
        ArrayList<String> result = new ArrayList<>()
        while (!deque.isEmpty()) {
            String top = deque.pop()
            println("$top 无依赖，加入结果集result")
            result.add(top)
            dependMap.entrySet().forEach {
                String path = it.key
                HashSet<String> dependDetail = it.value.dependDetail
                if (dependDetail.contains(top)) {
                    dependDetail.remove(top)
                    if (dependDetail.isEmpty() && !deque.contains(path) && !result.contains(path)) {
                        deque.offer(path)
                        println("$top 无依赖，加入待排序队列deque")
                    }
                }
            }
        }
        println("拓扑排序完成 $result")
        if (result.size() != dependMap.size()) {
            println("拓扑排序发现有环，无法进行下一步操作")
            throw new Exception("拓扑排序发现有环，无法进行下一步操作")
        }
        result.forEach {
            rootProject.project(it).ext.publishAArMethod()
        }
        println("所有组件发布成功")
    }
}