buildscript {
    dependencies {
        classpath files("${rootDir}/libs/snakeyaml-1.29.jar")
    }
}
import org.yaml.snakeyaml.*
import java.io.File

apply from: file("/utils.gradle")

def pomFile = new File("${rootDir}/config/aarPomConfig.yml")
if (!pomFile.exists()) {
    System.out.println("aarPomConfig don't exist")
    return
}

enum CompileMode {
    SOURCE,
    AAR
}

class AarConfig {
    String groupId
    String artifactId
    String version
    String projectPath
    CompileMode compileMode = CompileMode.SOURCE
}

class AarConfigManager {

    private LinkedHashMap<String, AarConfig> aarConfigs
    private Gradle gradle

    AarConfigManager(Gradle gradle, LinkedHashMap<String, AarConfig> aarConfigs) {
        this.gradle = gradle
        this.aarConfigs = aarConfigs
    }

    AarConfig getAarConfig(String dependencyNotation) {
        String notation = dependencyNotation.replaceAll(":", "/")
        return aarConfigs.get(notation)
    }

    String getGroupId(Project project) {
        String path = project.path
        AarConfig config = getAarConfig(path)
        return config.groupId
    }

    String getArtifactId(Project project) {
        String path = project.path
        AarConfig config = getAarConfig(path)
        return config.artifactId
    }

    String getVersion(Project project) {
        String path = project.path
        AarConfig config = getAarConfig(path)
        return config.version
    }
    /**
     * 该工程是否支持AAr,源码切换功能
     */
    boolean isAarEnableProject(Project project) {
        return getAarConfig(project.path) != null
    }

    /**
     * 获得所有source编译类型的module
     * @return
     */
    Collection<AarConfig> getSourceTypeProjectConfig() {
        return aarConfigs.values().findAll {
            it.compileMode == CompileMode.SOURCE
        }
    }

    /**
     * 获得所有aar编译类型的module
     * @return
     */
    Collection<AarConfig> getAARTypeProjectConfig() {
        return aarConfigs.values().findAll {
            it.compileMode == CompileMode.AAR
        }
    }

    /**
     * 获得所有aar编译类型的module
     * @return
     */
    Collection<AarConfig> getAllAArConfigs() {
        return aarConfigs.values()
    }
    /**
     * 发布AAr后，更新内存和文件的version版本
     */
    void updateAarVersion(String path, String version) {
        AarConfig aarConfig = getAarConfig(path)
        aarConfig.version = version
        def dumperOptions = new DumperOptions()
        dumperOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK)
        dumperOptions.setIndent(2)
        dumperOptions.setIndicatorIndent(2)
        dumperOptions.setIndentWithIndicator(true);
        def yaml = new Yaml(dumperOptions)
        Map<String, Object> data = new LinkedHashMap<String, Object>()
        ArrayList<LinkedHashMap<String, String>> list = new ArrayList<>()
        aarConfigs.values().forEach {
            LinkedHashMap<String, String> map = new LinkedHashMap<>()
            map.put("projectPath", it.projectPath)
            map.put("artifactId", it.artifactId)
            map.put("version", it.version)
            list.add(map)
        }
        data.put("projects", list)
        def pomFile = new File("${this.gradle.rootProject.rootDir}/config/aarPomConfig.yml")
        FileWriter fw = new FileWriter(pomFile)
        yaml.dump(data, fw)
    }
}

def dumperOptions = new DumperOptions()
dumperOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK)
def yaml = new Yaml(dumperOptions)
//读取module配置信息
def aarPomConfig = yaml.load(pomFile.newInputStream())
def groupId = "com.ct.ct"
def aarConfigs = [:]
(aarPomConfig.projects ?: []).each {
    def aarConfig = new AarConfig()
    aarConfig.groupId = groupId
    aarConfig.artifactId = it.artifactId
    aarConfig.version = it.version
    aarConfig.projectPath = it.projectPath
    aarConfigs.put(it.projectPath, aarConfig)
}
if (aarConfigs.size() == 0) {
    println("没有配置的Aar数据")
    return
}
//读取编译模式配置信息，默认 源码编译
def compileModeFile = new File("${rootDir}/config/compileModeConfig.yml")
def compileConfigs = [:]
if (compileModeFile.exists()) {
    compileConfigs = yaml.load(compileModeFile.newInputStream())
}

def taskName = gradle.startParameter.taskRequests[0]?.args.toString() ?: ""
def isPublishing = taskName?.contains(":uploadArchives") || taskName?.contains("PublicationToMavenRepository")

int aarNum = 0
aarConfigs.forEach { String key, AarConfig aarConfig ->
    boolean isAar = compileConfigs.get(key).equalsIgnoreCase("aar")
    if (isAar && aarConfig.version != "0") {
        aarConfig.compileMode = CompileMode.AAR
    }
    //发布AAR时，为了防止pom混乱，只能发布aar的module是源码化，其他都是aar化
    if (isPublishing) {
        aarConfig.compileMode = CompileMode.AAR
        if (taskName.contains("${aarConfig.projectPath.replaceAll("/", ":")}")) {
            aarConfig.compileMode = CompileMode.SOURCE
        }
    }
}

println("配置了 ${aarConfigs.size()}个Pom数据,其中${aarNum}个aar化，${aarConfigs.size() - aarNum}个源码化")

gradle.ext.aarConfigManager = new AarConfigManager(gradle, aarConfigs)

//引入所有源码依赖的project
gradle.settingsEvaluated { setting ->
    Collection<AarConfig> allSourceP = gradle.ext.aarConfigManager.getSourceTypeProjectConfig()
    allSourceP.forEach {
        setting.include it.projectPath.replaceAll("/", ":")
    }
}
gradle.beforeProject {
    it.afterEvaluate {
        AarConfigManager aarConfigManager = gradle.ext.aarConfigManager
        if (it == gradle.rootProject) {
            it.apply from: file("${rootDir}/script/publishAAr_RP.gradle")
            it.apply from: file("${rootDir}/script/fixDependence.gradle")
        } else {
            //设置依赖的aar强制版本
            it.configurations.all {
                Collection<AarConfig> list = aarConfigManager.getAARTypeProjectConfig()
                list.forEach {
                    String url = "${it.groupId}:${it.artifactId}:${it.version}"
                    resolutionStrategy.force url
                }
            }
            //设置maven_publish插件
            if ((isAndroidPlugin(it) || isJavaPlugin(it)) && aarConfigManager.isAarEnableProject(it)) {
                it.apply from: file("${rootDir}/script/maven_publish.gradle")
            }
        }
    }
    //基于gradle的动态特性设计，如果是build.gradle文件 则implementation projectOrAAr(":xxx") 直接接入
    it.ext.projectOrAAr = { String dependencyNotation ->
        AarConfigManager aarConfigManager = gradle.ext.aarConfigManager
        def aarConfig = aarConfigManager.getAarConfig(dependencyNotation)
        if (aarConfig == null || aarConfig.compileMode == CompileMode.SOURCE) {
            //刚开始时，代码是 return project(dependencyNotation),结果不能运行
            //因为这个脚本跑在setting.gradle脚本，方法定义时只能访问到gradle,没有project属性,访问不到project对象的project方法
            return gradle.rootProject.project(dependencyNotation)
        } else {
            def exclude = { module ->
                def sourceProjects = aarConfigManager.getSourceTypeProjectConfig()
                sourceProjects.forEach {
                    module.exclude group: "${it.groupId}", module: "${it.artifactId}"
                }
            }
            return ["${aarConfig.groupId}:${aarConfig.artifactId}:${aarConfig.version}", exclude]
        }
    }
}
